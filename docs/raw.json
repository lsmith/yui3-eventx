{"majorversion": 3, "classmap": {"Y.Event.API": {"name": "Y.Event.API", "constructors": [{"params": [{"type": "Object", "name": "config", "description": "  (optional) configuration object for this instance\n(see <code>_initEvents</code> for details)"}], "description": "Augmentation class to add event related API methods to instances of the host\nclass.  Use via <code>Y.augment(MyClass, Y.Event.API, true)</code>."}], "namespace": "", "module": "eventx-core", "methods": {"_initEvents": {"protected": "", "params": [{"type": "Object", "name": "config", "description": "  (optional) configuration for this instance"}], "description": "<p>Sets up the event collection, subscription collection, default\nevent, and other important state on the instance for managing and\ndispatching events.</p>\n<p>Accepts a config object with the following properties:</p>\n<ul>\n<li><code>events</code> - A collection of specific event\ndefinitions that override default behaviors for the augmented\nclass.</li>\n<li><code>defaultEvent</code> - event definition to use as a\nfallback for references to events not specifically included\nin the events collection.</li>\n<li><code>path</code> - bubble path</li>\n</ul>\n<p>If a config is not specified for the instance, it defaults from\na static <code>_events</code> property on the class constructor.  If\na class constructor is not present, the events collection is left\nempty, allowing all events to fall back to the\n<code>defaultEvent</code> methods.  If a <code>defaultEvent</code>\nis not identified, the global <code>Y.Event.API.defaultEvent</code>\nis used.</p>", "guessedname": "_initEvents", "guessedtype": "function"}, "bubbleTo": {"return": {"type": "Object", "description": "this instance"}, "description": "Add a bubble target, allowing subscriptions from the bubble target\nfor events emitted by this object.", "chainable": "", "params": [{"type": "Object", "name": "target", "description": "  instance of an object augmented with Event.API"}], "guessedname": "bubbleTo", "guessedtype": "function"}, "eventDef.detach": {"return": {"type": "boolean", "description": "true to detach, false to abort"}, "description": "<p>Subscription tear down or other work that needs to happen each time\na subscription detach is requested.  If the method returns true, the\nsubscription will be detached.  Return false to abort the detach.</p>", "protected": "", "static": "", "guessedname": "detach", "guessedtype": "function", "params": [{"type": "Object", "name": "host", "description": "  the instance from which on/after was called"}, {"type": "Object", "name": "sub", "description": "  the subscription to detach"}, {"type": "any", "name": "args*", "description": "  additional arguments passed to <code>detach(..)</code>"}]}, "subscribe": {"return": {"type": "Object", "description": "this instance"}, "description": "<p>Subscribe to an event on this object.  This method is a catchall\nfor events that might support more than the standard \"before\" (aka\n\"on\") and \"after\" phases.  This method allows for subscription to\nany event phase.</p>\n<p>The first argument must be a type string identifying the event.\nThe string can include a detach category.  Additionally, if no event\nspecifically matches the type string, a conditional event might be\nused if its <code>test(..)</code> method indicates a match.\nOtherwise, the default event definition will be used for the\nspecified type.</p>\n<p>The second argument must be a phase string.  Passing the string\n\"before\", for example, mimics the behavior of\n<code>on(...)</code>.</p>\n<p>Individual events can define how the subscription params are\nhandled, but the default signature is\n<code>subscribe( type, phase, callback, thisObj, arg0..argN )</code>\nwhere <code>thisObj</code> will be used for 'this' in the callback,\nand the additional arguments will be passed to the callback after\nthe event object.</p>", "chainable": "", "params": [{"type": "String", "name": "type", "description": "  event type to subcribe to, with optional detach\ncategory"}, {"type": "String", "name": "phase", "description": "  event phase to attach subscription"}, {"type": "any", "name": "arg*", "description": "  see above note on default signature"}], "guessedname": "subscribe", "guessedtype": "function"}, "eventDef._immediate": {"return": {"type": "boolean", "description": "false (prevents formal subscription)"}, "description": "Replacement for the subscribe method on fireOnce events after they've\nfired.  Immediately executes the would be subscription.", "protected": "", "static": "", "guessedname": "_immediate", "guessedtype": "function", "params": [{"type": "Object", "name": "host", "description": "  the instance from which on/after was called"}, {"type": "Object", "name": "sub", "description": "  the initial subscription object"}, {"type": "any", "name": "args*", "description": "  any additional arguments passed on(type, _here_...)"}]}, "eventDef.generateEvent": {"return": {"type": "Object", "description": "the event object"}, "description": "<p>Called by fire.  Creates the event object that will be passed to the\nsubscribers.  The event has the following properties and methods:</p>\n<ul>\n<li><code>type</code></li>\n<li><code>target</code></li>\n<li><code>preventDefault()</code></li>\n<li><code>_prevent</code> (reserved)</li>\n<li><code>stopPropagation()</code></li>\n<li><code>stopImmediatePropagation()</code></li>\n<li><code>_stop</code> (reserved)</li>\n<li><code>halt()</code> - stopPropagation() + preventDefault()</li>\n<li><code>detach()</code> - detaches the current subscriber</li>\n<li><code>details</code> - array of additional args passed to\n<code>fire(type, <em>_here_...</em>)</code></li>\n</ul>\n<p>If the first additional argument is an object, its properties will be\nadded to the event object directly as well as being the object being\nincluded in the <code>details</code> property.</p>\n<p>Before it is passed to subscribers, its <code>currentTarget</code> and\n<code>subscription</code> properties are updated accordingly by the\n<code>notify</code> method.</p>", "protected": "", "static": "", "guessedname": "generateEvent", "guessedtype": "function", "params": [{"type": "Object", "name": "host", "description": "  the instance from which on/after was called"}, {"type": "String", "name": "type", "description": "  the name of the event"}, {"type": "any", "name": "args*", "description": "  additional data provided to subscribers."}]}, "eventDef.subscribe": {"return": {"type": "boolean", "description": "true to allow subscription, false to abort"}, "description": "<p>Subscription setup or other work that needs to happen each time\na subscription is requested.  At the point this method receives the\nsubscription, it will only contain the following properties:</p>\n<ul>\n<li><code>type</code> - the event name</li>\n<li><code>phase</code> - \"on\" or \"after\" (unless your event supports\nmore than these two default phases)</li>\n<li><code>category</code> - (string) if the subscription was\ngenerated with a detach category, e.g. for on('foo:click', ...),\nthis would contain \"foo\"</li>\n<li><code>host</code> - the instance from which on(..) was\ncalled</li>\n<li><code>detach()</code> - method to detach this subscription</li>\n</ul>\n<p>It is the purpose of this method to add anything uniquely appropriate\nfor this event to the subscription, such as <code>sub.callback</code> to\nfacilitate notifications or identifying it for detach.</p>\n<p>Return true to allow the subscription to occur, or false to abort.</p>", "protected": "", "static": "", "guessedname": "subscribe", "guessedtype": "function", "params": [{"type": "Object", "name": "host", "description": "  the instance from which on/after was called"}, {"type": "Object", "name": "sub", "description": "  the initial subscription object"}, {"type": "any", "name": "args*", "description": "  any additional arguments passed on(type, _here_...)"}]}, "eventDef.test": {"return": {"type": "boolean", "description": "true to indicate that this event should handle the\nsubscription"}, "static": "", "protected": "", "params": [{"type": "Object", "name": "host", "description": "  the instance from which on/after was called"}, {"type": "String", "name": "type", "description": "  the type string passed to <code>on(..)</code> or\n<code>after(..)</code>"}, {"type": "any", "name": "args*", "description": "  additional arguments after type and phase (e.g.\ncallback function)"}], "description": "<p>Test the provided event type string and other args passed to\n<code>on(type, ...)</code> or <code>after(type, ...)</code> to indicate\nthat this event definition should handle the subscription.  By default,\nevent mapping is a direct type string => event definition.  This allows\nfor more generic type strings that can be used to trigger specific\nbehavior in the <code>init</code> or <code>subscribe</code> methods.\nAn example would be a regex based test that matched\n<code>on(\"key(shift+enter)\", ...)</code>.</p>\n<p>Return true to indicate that this event should handle the\nsubscription.</p>\n<p>This is optional for any event, but can also be included in a default\nevent.  By default, a simple type => event mapping is used.</p>"}, "publish": {"return": {"type": "Object", "description": "the instance"}, "description": "<p>Add a new event to this instance's collection of events.  Use\nthis to add an event with specific default behavior, ifPrevented\nbehavior, or special subscription/detach logic (etc).  If the event\ndoesn't behave in any way different from the default, you don't have\nto publish it.  If the event applies to all instances, define it in\nthe static <code>_events</code> collection for the class.</p>\n<p>Accepts an event definition object with properties and methods to\noverride those defined in the <code>defaultEvent</code>.  See the\ndescription of <code>Y.Event.API.defaultEvent</code> for the\nproperties and methods to include.  Any methods or properties not\ndefined will be provided by the <code>defaultEvent</code>.</p>\n<p>If the <code>pattern</code> property is set to a regular\nexpression, it will be wrapped in a memoized <code>test</code>\nfunction automatically.</p>\n<p>Include a <code>type</code> property in the event definition, or\npass the type string as the first parameter and the overrides as the\nsecond.</p>", "chainable": "", "params": [{"type": "Object", "name": "eventDef", "description": "  collection of event methods/properties"}], "guessedname": "publish", "guessedtype": "function"}, "eventDef.filterSubs": {"return": {"type": "Array", "description": "all subscription objects not filtered out"}, "description": "Used to prevent duplicate subscriptions (if applicable) and to locate\nthe correct subscription(s) to detach.  Takes a list of all applicable\nsubscriptions and a subscription kernel and any other arguments\npassed <code>on(type, <em>_here_...</em>)</code> or\n<code>detach(type, phase, <em>_here_...</em>)</code> and returns a list\nof subscriptions that are a potential match based on the input.", "protected": "", "static": "", "guessedname": "filterSubs", "guessedtype": "function", "params": [{"type": "Array", "name": "subs", "description": "  All subscriptions for a given type and phase\n(optionally within a category)"}, {"type": "Object", "name": "refSub", "description": "  subscription kernel identifying host, type,\nphase, and category"}, {"type": "any", "name": "args*", "description": "  additional arguments passed to on(..) or detach(..)\nused to refine the filter"}]}, "eventDef.fire": {"description": "<p>Executes subscribers for the \"before\" (aka \"on\") phase for all targets\nin the bubble chain until propagation is stopped or the last target is\nnotified.  If not prevented and if the event has one, the default\nbehavior is executed.  Then the executes subscribers for the \"after\"\nphase up the bubble chain.</p>\n<p>If the event is prevented and it has one, the <code>ifPrevented</code>\nmethod is executed.  \"after\" phase subscribers are not executed if the\nbehavior is prevented.</p>\n<p>Similarly, if the event propagation is stopped and it has one, the\n<code>ifStopped</code> method is executed.  Note, this will not prevent\nthe default behavior or the \"after\" subscribers from being executed.</p>", "protected": "", "static": "", "guessedname": "fire", "guessedtype": "function", "params": [{"type": "Object", "name": "host", "description": "  the instance from which fire was called"}, {"type": "String", "name": "type", "description": "  the event type to dispatch"}, {"type": "any", "name": "args*", "description": "  additional args passed <code>fire(type,\n<em>_here_...</em>)</code>"}]}, "_subscribe": {"return": {"type": "Object", "description": "this instance"}, "description": "Does the work for <code>on(..)</code>, <code>after(..)</code>, and\n<code>subscribe(..)</code>.", "chainable": "", "protected": "", "params": [{"type": "Array", "name": "args", "description": "  [type, phase, arg*] to identify and dispatch to\nthe appropriate event definition"}], "guessedname": "_subscribe", "guessedtype": "function"}, "eventDef.notify": {"description": "<p>Executes all the subscribers in a bubble chain for an event in a given\nphase (\"before\" or \"after\").  Used by <code>fire</code>.</p>\n<p>If a subscriber calls <code>e.stopImmediatePropagation()</code>, no\nfurther subscribers will be executed, and if a subscriber calls\n<code>e.stopPropagation()</code>, no further bubble targets will be\nnotified.</p>", "protected": "", "static": "", "guessedname": "notify", "guessedtype": "function", "params": [{"type": "Array", "name": "path", "description": "  bubble targets in the order they should be notified"}, {"type": "Object", "name": "event", "description": "  the event to pass to the subscribers"}, {"type": "String", "name": "phase", "description": "  the phase location of the subscribers"}]}, "hasSubscribers": {"return": {"type": "boolean", "description": ""}, "params": [{"type": "String", "name": "type", "description": "  the name of the event"}, {"type": "String", "name": "phase", "description": "  (optional) the phase in which to check"}], "description": "<p>Returns true if there are any subscriptions in a given phase for\na particular event.  If no phase is specified, all phases are\nchecked.</p>\n<p>The type string alone will be used to identify the event whose\n<code>fire</code> definition should be used, and will not be\ncompared against conditional events' <code>test(..)</code>\nmethods.</p>", "guessedname": "hasSubscribers", "guessedtype": "function"}, "pushToPath": {"params": [{"type": "Object", "name": "o", "description": "  object root of the path"}, {"type": "Array", "name": "path", "description": "  property names identifying the nesting location"}, {"type": "any", "name": "subject", "description": "  the item to push to the array"}], "description": "Pushes an object onto an array located at the path identified by following\nthe property name strings in the <code>path</code> parameter.  If any\npoint on the path doesn't exist, it is created.  The last point in the path\nshould be an array.\nE.g. <code>var x = {}; pushToPath(x, ['foo','bar'], 1)</code>\nwould result in <code>x</code> structured like\n<code>{ foo: { bar: [ 1 ] } }</code>", "private": ""}, "fire": {"return": {"type": "Object", "description": "this instance"}, "description": "<p>Trigger the execution of subscribers to a specific event.  The\nparticular logic used for the notification is defined in the event\ndefinition's <code>fire(..)</code> method.  If not specified there,\nthe default event's <code>fire(..)</code method is used.</p>\n<p>As noted in <code>eventDef.fire</code>, the global default\nevent's <code>fire</code> executes the \"before\" (aka \"on\") phase\nsubscribers, then the event's default behavior if it has one, then\nthe \"after\" phase subscribers, but this can be overridden per\nevent.  More detail is available in the API doc for\nthe (protected) <code>eventDef.fire</code> method.</p>\n<p>The type string alone will be used to identify the event whose\n<code>fire</code> definition should be used, and will not be\ncompared against conditional events' <code>test(..)</code>\nmethods.</p>", "chainable": "", "params": [{"type": "String", "name": "type", "description": "  the type identifying the event whose\n<code>fire(..)</code> to use."}, {"type": "any", "name": "args*", "description": "  extra arguments to pass along"}], "guessedname": "fire", "guessedtype": "function"}, "eventDef.destroy": {"return": {"type": "boolean", "description": "true to allow subscription, false to abort"}, "static": "", "protected": "", "params": [{"type": "Object", "name": "host", "description": "  the instance from which on/after was called"}, {"type": "String", "name": "type", "description": "  the event to tear down"}, {"type": "any", "name": "args*", "description": "  any additional arguments passed on(type, _here_...)"}], "description": "Final one-time tear down for an event.  E.g. for DOM events, only\none actual DOM subscription is made, the first time a subscription is\nrequested.  A custom event is used to manage this and subsequent\nsubscriptions.  After the last subscriber is detached, this is executed."}, "after": {"return": {"type": "Object", "description": "this instance"}, "description": "<p>Subscribe to an event on this object.  Subscribers in this\n\"after\" phase will NOT have access to prevent any default event\nbehaviors (if the event permits prevention), but will also not\nbe executed unless the default behavior executes.</p>\n<p>The first argument must be a type string identifying the event.\nThe string can include a detach category.  Additionally, if no event\nspecifically matches the type string, a conditional event might be\nused if its <code>test(..)</code> method indicates a match.\nOtherwise, the default event definition will be used for the\nspecified type.</p>\n<p>Individual events can define how the subscription params are\nhandled, but the default signature is\n<code>after( type, callback, thisObj, arg0..argN )</code> where\n<code>thisObj</code> will be used for 'this' in the callback, and\nthe additional arguments will be passed to the callback after the\nevent object.</p>", "chainable": "", "params": [{"type": "String", "name": "type", "description": "  event type to subcribe to, with optional detach\ncategory"}, {"type": "any", "name": "arg*", "description": "  see above note on default signature"}], "guessedname": "after", "guessedtype": "function"}, "_resolveBubblePath": {"return": {"type": "Array", "description": "the ordered list of target instances"}, "description": "<p>Flattens the bubble path for a given root instance.  Used by the\ndefault <code>fire</code> definition, but available for any customized\n<code>fire</code> logic.  Flattens using a breadth-first algo, so given\nthe following bubble structure:</p>\n<pre>\n. (D)  (E)   (D)  (F)\n.    \\  |     |  /\n.     (B)     (C)       bubble up to\n.        \\   /\n.         (A)           bubbles up to</pre>\n<p>The resulting bubble path would be [A, B, C, D, E, F], and not\n[A, B, D, E, C, F] (depth-first).  Also note duplicate targets are\nignored.  The first appearance in the bubble path wins.</p>", "protected": "", "static": "", "guessedname": "_resolveBubblePath", "guessedtype": "function", "params": [{"type": "Object", "name": "root", "description": "  the origin of the event to bubble (A in the diagram)"}]}, "detach": {"return": {"type": "Object", "description": "this instance"}, "description": "<p>Unsubscribe one or multiple subscribers.  Some example signatures\nare:</p>\n<table>\n<thead>\n<tr><th>Called with</th><th>What is detached</th></tr>\n</thead>\n<tbody>\n<tr>\n<td><code>detach()</code></td>\n<td>All subscriptions to all events in all phases</td>\n</tr>\n<tr>\n<td><code>detach(subscriptionObject)</code></td>\n<td>That subscription</td>\n</tr>\n<tr>\n<td><code>detach(\"foo\")</code></td>\n<td>All subscriptions to event \"foo\" in all phases</td>\n</tr>\n<tr>\n<td><code>detach(\"foo\", \"before\")</code></td>\n<td>All subscriptions to event \"foo\" in the \"before\"\nphases</td>\n</tr>\n<tr>\n<td><code>detach(\"foo\", \"before\", callbackFunc)*</code></td>\n<td>All subscriptions to event \"foo\" in the \"before\"\nphase that are bound to callbackFunc  (*See below for\nnotes)</td>\n</tr>\n<tr>\n<td><code>detach(\"cat:*\")</code></td>\n<td>All subscriptions to all events in all phases that\nwere subscribed with category \"cat\" (e.g.\n<code>on(\"cat:foo\", ...)</code>)</td>\n</tr>\n<tr>\n<td><code>detach(\"cat:foo\")</code></td>\n<td>All subscriptions to event \"foo\" in all phases that\nwere subscribed with category \"cat\"</td>\n</tr>\n</tbody>\n</table>\n<p>Note, parameters beyond the type and phase are passed to the\nevent's <code>filterSubs</code> method to apply any signature\nspecific filtration for the subscriber list, so the detach signature\nthat passes the callback is just an example of the signature\nsupported by the default event.</p>", "chainable": "", "params": [{"type": "Object|String", "name": "typeSpec", "description": "  (optional) event subscription object\nor event type string, optionally with category"}, {"type": "String", "name": "phase", "description": "  (optional) phase from which to detach"}, {"type": "any", "name": "args*", "description": "  additional arguments used by the event's\n<code>filterSubs</code> method to better\nisolate which sub(s) to detach."}], "guessedname": "detach", "guessedtype": "function"}, "on": {"return": {"type": "Object", "description": "this instance"}, "description": "<p>Subscribe to an event on this object.  Subscribers in this\n\"before\" phase will have access to prevent any default event\nbehaviors (if the event permits prevention).</p>\n<p>The first argument must be a type string identifying the event.\nThe string can include a detach category.  Additionally, if no event\nspecifically matches the type string, a conditional event might be\nused if its <code>test(..)</code> method indicates a match.\nOtherwise, the default event definition will be used for the\nspecified type.</p>\n<p>Individual events can define how the subscription params are\nhandled, but the default signature is\n<code>on( type, callback, thisObj, arg0..argN )</code> where\n<code>thisObj</code> will be used for 'this' in the callback, and\nthe additional arguments will be passed to the callback after the\nevent object.</p>", "chainable": "", "params": [{"type": "String", "name": "type", "description": "  event type to subcribe to, with optional detach\ncategory"}, {"type": "any", "name": "arg*", "description": "  see above note on default signature"}], "guessedname": "on", "guessedtype": "function"}, "getEvent": {"return": {"type": "Object", "description": "an event definition object"}, "params": [{"type": "String", "name": "type", "description": "  the name of the event"}, {"type": "Array", "name": "match", "description": "  (optional) additional args to pass to\n<code>test(..)</code> to match against any\nhosted conditional events"}], "description": "Finds the best match for the type specified, optionally testing\nagainst any hosted conditional events.  If all else fails, the\ndefault event definition is returned.", "guessedname": "getEvent", "guessedtype": "function"}, "eventDef.init": {"static": "", "protected": "", "params": [{"type": "Object", "name": "host", "description": "  the instance from which on/after was called"}, {"type": "Object", "name": "sub", "description": "  the initial subscription object"}], "description": "Initial one-time setup for an event.  E.g. for DOM events, only\none actual DOM subscription is made, the first time a subscription is\nrequested.  A custom event is used to manage this and subsequent\nsubscriptions in order to guarantee subscriber execution order.  Also\nsee <code>eventDef.destroy</code>."}}, "file": "event.js", "shortname": "Y.Event.API", "properties": {"defaultEvent": {"type": "{Object}", "static": "", "description": "<p>Default lifecycle methods for any unknown event being referenced by the\nAPI. This is the generic custom event behavior.</p>\n<p>To define specific events (only needed if they require special behavior),\nyou can describe them statically on the class in an <code>_events</code>\nproperty.  Typically, you'll want to use the class's defaultEvent as the\nprototype of any special events.  E.g.</p>\n<pre><code>\n. MyClass._events = {\n.     events: {\n.         // define special behavior for a 'foo' event on all instances\n.         foo: Y.Object(Y.Event.API.defaultEvent, {\n.             init: function (host, subscription, callback) { ... }\n.             destroy: function (host, type) { ... }\n.             // all other behaviors inherited from the defaultEvent\n.         })\n.     }\n. };\n. Y.augment(MyClass, Y.Event.API, true);</code></pre>\n<p>If defining new default behaviors for a class, the default event\ndefinition will need to implement the following methods:</p>\n<ul>\n<li><code>subscribe(host, subscription_kernel, args*)</code></li>\n<li><code>detach(host, subscription, args*)</code></li>\n<li><code>fire(host, type, *)</code></li>\n<li><code>filterSubs(subsArray, subscription_kernel, args*)</code></li>\n</ul>\n<p>Return false from either to prevent the subscription or detach\nrespectively.</p>\n<p>The API also supports the following properties/methods:</p>\n<ul>\n<li><code>init(host, subscription_kernel, args*)</code></li>\n<li><code>allowDups</code> (true|false) property</li>\n<li><code>destroy(host, type)</code></li>\n<li><code>test(type, args*)</code> (function)</li>\n</ul>\n<p>Each method is called passing the event definition as 'this', and the\ncalling object as the first arg (except for <code>filterSubs</code>).  You\ncan include any more or methods or properties on an event definition, but\nthe definition object should not manage state (e.g. fireOnce should not\nupdate a property on the event definition) unless it that state applies to\nall instances and derived event definitions.</p>\n<p>See the descriptions for the individual eventDef methods and\nproperties.</p>", "guessedname": "defaultEventDef", "guessedtype": "property"}, "_event": {"description": "<p>Default prototype for emitted event objects.  Contains the following\npropeties and methods:</p>\n<ul>\n<li><code>_prevent</code></li>\n<li><code>_stop</code></li>\n<li><code>preventDefault()</code></li>\n<li><code>stopPropagation()</code></li>\n<li><code>stopImmediatePropagation()</code></li>\n<li><code>halt()</code> - stopPropagation() + preventDefault()</li>\n<li><code>detach()</code></li>\n</ul>", "protected": "", "static": "", "guessedname": "_event", "guessedtype": "property", "type": "{Object}"}, "eventDef.allowDups": {"type": "{boolean}", "protected": "", "static": "", "description": "Control whether duplicate subscriptions to this event should be allowed.\nIf false, the API will use the event definition's\n<code>filterSubs</code> method to search the existing subscriptions for\nduplicates.  If one is found, the subscription will be aborted before\nreaching the <code>subscribe</code> method."}, "TYPE_PATTERN": {"description": "Pattern used to split detach category from event type.  By default,\nIt matches <code>on(\"foo:bar\",..)</code> as category \"foo\" and type\n\"bar\", and <code>on(\"baz\",..)</code> as category \"\" and type as \"baz\".", "default": "/(?:([^:]+?):)?(.*)/", "protected": "", "static": "", "guessedname": "TYPE_PATTERN", "guessedtype": "property", "type": "{Regexp}"}}, "description": "Augmentation class to add event related API methods to instances of the host\nclass.  Use via <code>Y.augment(MyClass, Y.Event.API, true)</code>."}}, "version": "3", "modules": {"eventx-core": {"description": "Alternate event API augmentation class.", "submodules": [], "classlist": ["Y.Event.API"], "filelist": ["event-dom-ie.js", "event-dom.js", "event-min.js", "event-node-domready.js", "event-node-focus.js", "event-node.js", "event.js"], "subdata": {}, "name": "eventx-core"}}, "filemap": {"event-min.js": {"name": "event-min.js", "classlist": [], "module": "eventx-core", "guessedname": "h", "guessedtype": "function", "method": "h"}, "event-node.js": {"classlist": [], "name": "event-node.js", "module": "eventx-core"}, "event-dom-ie.js": {"classlist": [], "name": "event-dom-ie.js", "module": "eventx-core"}, "event-dom.js": {"classlist": [], "name": "event-dom.js", "module": "eventx-core"}, "event-node-focus.js": {"classlist": [], "name": "event-node-focus.js", "module": "eventx-core"}, "event.js": {"classlist": ["Y.Event.API"], "name": "event.js", "module": "eventx-core"}, "event-node-domready.js": {"classlist": [], "name": "event-node-domready.js", "module": "eventx-core"}}}